%module librealsense2

// make all Java methods generated by SWIG as public
SWIG_JAVABODY_PROXY(public, public, SWIGTYPE)
SWIG_JAVABODY_TYPEWRAPPER(public, public, public, SWIGTYPE)

/*
 * All types below are declared as typedefs in librealsense
 * and SWIG does not know their definitions.
 * As the result it cannot define classes for them.
 * To fix that we provide empty definitions here.
 * That way it helps SWIG to generate the classes. There is
 * no need to have exact definitions since in librealsense API they
 * are used as pointers only and therefore SWIG will generate
 * same wrapping for them anyway.
 */
%{
struct rs2_error {};
struct rs2_device_info {};
struct rs2_device {};
struct rs2_log_message {};
struct rs2_raw_data_buffer {};
struct rs2_frame {};
struct rs2_frame_queue {};
struct rs2_pipeline {};
struct rs2_pipeline_profile {};
struct rs2_config {};
struct rs2_device_list {};
struct rs2_stream_profile_list {};
struct rs2_processing_block_list {};
struct rs2_stream_profile {};
struct rs2_frame_callback {};
struct rs2_log_callback {};
struct rs2_syncer {};
struct rs2_device_serializer {};
struct rs2_source {};
struct rs2_processing_block {};
struct rs2_frame_processor_callback {};
struct rs2_playback_status_changed_callback {};
struct rs2_update_progress_callback {};
struct rs2_context {};
struct rs2_device_hub {};
struct rs2_sensor_list {};
struct rs2_sensor {};
struct rs2_options {};
struct rs2_options_list {};
struct rs2_devices_changed_callback {};
struct rs2_notification {};
struct rs2_notifications_callback {};
struct rs2_firmware_log_message {};
struct rs2_firmware_log_parsed_message {};
struct rs2_firmware_log_parser {};
struct rs2_terminal_parser {};
%}
struct rs2_error {};
struct rs2_device_info {};
struct rs2_device {};
struct rs2_log_message {};
struct rs2_raw_data_buffer {};
struct rs2_frame {};
struct rs2_frame_queue {};
struct rs2_pipeline {};
struct rs2_pipeline_profile {};
struct rs2_config {};
struct rs2_device_list {};
struct rs2_stream_profile_list {};
struct rs2_processing_block_list {};
struct rs2_stream_profile {};
struct rs2_frame_callback {};
struct rs2_log_callback {};
struct rs2_syncer {};
struct rs2_device_serializer {};
struct rs2_source {};
struct rs2_processing_block {};
struct rs2_frame_processor_callback {};
struct rs2_playback_status_changed_callback {};
struct rs2_update_progress_callback {};
struct rs2_context {};
struct rs2_device_hub {};
struct rs2_sensor_list {};
struct rs2_sensor {};
struct rs2_options {};
struct rs2_options_list {};
struct rs2_devices_changed_callback {};
struct rs2_notification {};
struct rs2_notifications_callback {};
struct rs2_firmware_log_message {};
struct rs2_firmware_log_parsed_message {};
struct rs2_firmware_log_parser {};
struct rs2_terminal_parser {};

%include <typemaps.i>
%apply int* OUTPUT {rs2_stream* stream};
%apply int* OUTPUT {rs2_format* format};
%apply int* OUTPUT {int* index};
%apply int* OUTPUT {int* unique_id};
%apply int* OUTPUT {int* framerate};

%{
#include "rs_types.h"
%}
%include "rs_types.h"

%{
#include "rs.h"
%}
%include "rs.h"

%{
#include "rs_context.h"
%}
%include "rs_context.h"

%{
#include "rs_pipeline.h"
%}
%include "rs_pipeline.h"

%{
#include "rs_device.h"
%}
%include "rs_device.h"

%{
#include "rs_sensor.h"
%}
%include "rs_sensor.h"

%{
#include "rs_config.h"
%}
%include "rs_config.h"

%{
#include "rs_frame.h"
%}
%include "rs_frame.h"

/*
 * Some of rs2 functions accept pointer to pointers.
 * In order to create and use such variables in Java we
 * ask SWIG to generate additional methods for them
 */
%include "cpointer.i"
%pointer_functions(rs2_frame*, rs2_frame_ptr)
%pointer_functions(rs2_error*, rs2_error_ptr)

%{
#include "rs_processing.h"
%}
%include "rs_processing.h"

/*
 * Here for internal usage in debug builds
 */
%{
void debug(const char* format, ...) {
  char msg[1024];
  va_list args;
  va_start(args, format);
  vsnprintf(msg, 1023, format, args);
  va_end (args);
  FILE *fp = fopen("/tmp/jrealsense.log", "w");
  fprintf(fp, msg);
  fclose(fp);
}
%}

/*
 * This function allows to access data in native memory from Java.
 * To do that it relies on direct buffers and wraps native memory to ByteBuffer
 * object which later can be used in Java.
 */
%native (create_ByteBuffer) jobject create_ByteBuffer(void* dataPtr, int capacity);
%{
JNIEXPORT jobject JNICALL Java_id_jrealsense_jni_librealsense2JNI_create_1ByteBuffer(
    JNIEnv *jenv, jclass clazz, jlong dataPtr, jint capacity)
{
  return (*jenv)->NewDirectByteBuffer(jenv, (void*)(dataPtr), (jlong)capacity);  
}
%}

/*
 * Function to retrieve vertices from the frame in one call to improve performance
 */
%native (create_vertexByteBuffer) jobject create_vertexByteBuffer(rs2_frame* frame, rs2_error** error);
%{
JNIEXPORT jobject JNICALL Java_id_jrealsense_jni_librealsense2JNI_create_1vertexByteBuffer(
    JNIEnv *jenv, jclass clazz, jlong framePtr, jlong errorPtr)
{
  rs2_error* e = *(rs2_error**)errorPtr;
  e = NULL;
  rs2_vertex* vertices = rs2_get_frame_vertices((rs2_frame*)framePtr, &e);
  if (e) return 0;
  int count = rs2_get_frame_points_count((rs2_frame*)framePtr, &e);
  if (e) return 0;
  return (*jenv)->NewDirectByteBuffer(jenv, (void*)(vertices), (jlong)(count * sizeof(rs2_vertex)));
}
%}
